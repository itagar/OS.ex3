itagar
Itai Tagar (305392508)
EX: 3


FILES:
	MapReduceFramework.cpp  - The MapReduce Framework implementation.
	Thread.h                - A wrapper class for a Thread in the Framework.
	MapThread.h             - A wrapper class for a Map Thread in the Framework.
	ReduceThread.h          - A wrapper class for a Reduce Thread in the Framework.
	Search.cpp              - The program which perform search using the Framework.
	Makefile                - Makefile for this project.
	README                  - This file.


REMARKS:
Design of the Search program:
    In the Search program I divided the work between the Map and Reduce as follows:
    The Map function is given a directory and the substring and it then search
    in the files in the given directory the substring. Map is calls Emit2 of every
    file name in this directory which satisfies the filter condition (in our case is
    that the name contains the substring). So the Map helps the Search program
    to divide it's work on the user input into several tasks where each task
    is dedicated to one argument (one directory path) from the program arguments.
    The Reduce function is fed with a filename and a list of K2 values and for every
    item in the list, it calls Emit3 with this file name. So Reduce helps the Search
    program divide it's work to counting every file name occurrence in a single
    Reduce progress.
    As described, my implementation of K1 is a directory name and V1 is a substring.
    The implementation of K2 is the file name, which emitted by Map while filtering
    the directory (K1) using the substring (V1). As for V2, it does not have a
    specific implementation because the whole use of the value is to serve as a
    counter of appearances for each file name (K2). So every Emit2 will emit
    the file name with a nullptr and when the Reduce phase will take action it will
    merely count the size of the list of (V2) i.e. the number of nullptr items.
    As for K3 this is also representing a file name which passed the filtering.
    Again, for V3 the implementation was not required because the final output
    of the Search program is printing the file names without any additional
    information.

Design of the Framework implementation:
    The Framework is supported by the Thread class which is a wrapper class
    for the pthread_t object and has some useful data and functions in order
    to maintain the Framework and the Threads more easily.
    The Framework holds several shared data and the Threads containers are one of them.
    For the Map and Reduce Threads I used a Vector which holds a MapThread/ReduceThread
    for each Thread respectively. For every shared data there is a Mutex to maintain
    concurrency.
    While the Map procedure is running, each MapThread object has it's own
    Vector of K2, V2 pairs and each Emit2 call is adding the values to the corresponding
    Thread's Vector. The same goes for the ReduceThreads while using Emit3. When the
    Shuffle Thread wants to do some shuffling it searches in the MapThreads Vector
    for a MapThread which holds items in its Vector and shuffle it's item while clearing
    it's Vector. All the Shuffle results are in a shared map which maps K2 to
    V2 Vector. Using map allows more efficiency in run time.
    The communication between Shuffle and Map is by a Semaphore which indicates
    to the Shuffle when Emit2 occurred and it can wake up and shuffle. Some useful
    flag is the flag indicates that all the MapThreads finished their work. In that
    case we wake up the Shuffle one more time to clear and shuffle all the items
    from all the MapThreads.
    As I mentioned each MapThread holds it's own Vector of K2, V2. In addition
    each MapThread holds a Mutex for this Vector. This Mutex is used for concurrency
    between writing to the Vector by Map and between reading from the Vector by Shuffle
    (and clearing it as well).
    Reduce using the shared map created by Shuffle while maintaining a global
    Iterator (which is locked by Mutex) which works the same as the global index
    for the input items and the Map procedure.
    When Reduce finished it's task, the main Thread then merges all the items
    from all the ReduceThreads in one output Vector, sorts it and returns it.
    When dealing with releasing the resources of K2, V2 I first checked inside the Shuffle
    if a deletion is required. A deletion is required in the Shuffle if the current
    K2 is already in the Shuffle map thus we append it's V2 to the already existing K2.
    If this is the case (and autoDeleteV2K2 is true) then Shuffle frees it's memory.
    Now in the main Thread that runs RunMapReduceFramework, we iterate through the
    entire Shuffle map and release all the K2 keys with all the V2 in every
    Vector of this K2. Working like this assures that all the K2 and V2 are freed because
    all the V2 are never gets lost during the Framework process and for every K2 that
    got lost we take care of it's memory in the Shuffle procedure.


ANSWERS:
Theoretical Questions:
    1. Bla.

    2. Bla.

    3.  a. Bla.
        b. Bla.
        c. Bla.
        d. Bla.
        e. Bla.

    4. 	a. Stack:
            - Kernel-Level Thread - The stack isn't shared between parent and it's child.
			- User-Level Thread -   The stack isn't shared between parent and it's child.
			- Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the stack.
		b. Heap:  
            - Kernel-Level Thread - The heap is shared between parent and child.
			- User-Level Thread -   The heap is shared between parent and child.
            - Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the heap.
        c. Global Variables:
            - Kernel-Level Thread - The global variables are shared between the parent
                                    and it's child.
            - User-Level Thread -   The global variables are shared between the parent
                                    and it's child.
            - Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the
                                    global variables.

    5. The difference between deadlock and livelock is that in deadlock there are two
	or more threads/processes which hold some lock and wait for the lock of others and 
	so each one is watining for the other in some cyclic waiting, hence locked. 
	While in livelock the processes are locked, like in deadlock, the reason for this
	is different. In livelock each process is constantly changing it's state in order
	to assist the other processes to continue with their progress, so in livelock
	everybody is trying to make everybody to run, thus not making any progress, 
	and in deadlock each one is trying to make it's own process to run. As we mentioned 
	in class, livelock is a state where everybody is too polite, and we can think of 
	livelock as a situation of the processes trying to avoid in reaching a deadlock.
	An example of deadlock is like in the Dining Philosophers where each philosopher
	is holding one chopstick and attempts to hold the other chopstick, which is already
	held by another philosopher.
	An example of livelock is when two people attemp to get inside a room and get stuck
	the entrance because each one is too polite and wait for the other to get inside
	before him.
