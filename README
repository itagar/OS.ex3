itagar
Itai Tagar (305392508)
EX: 3


FILES:
	MapReduceFramework.cpp  - The MapReduce Framework implementation.
	Thread.h                - A wrapper class for a Thread in the Framework.
	MapThread.h             - A wrapper class for a Map Thread in the Framework.
	ReduceThread.h          - A wrapper class for a Reduce Thread in the Framework.
	Search.cpp              - The program which perform search using the Framework.
	Makefile                - Makefile for this project.
	README                  - This file.


REMARKS:
Design of the Search program:
    In the Search program I divided the work between the Map and Reduce as follows:
    The Map function is given a directory and the substring and it then search
    in the files in the given directory the substring. Map is calls Emit2 of every
    file name in this directory which satisfies the filter condition (in our case is
    that the name contains the substring). So the Map helps the Search program
    to divide it's work on the user input into several tasks where each task
    is dedicated to one argument (one directory path) from the program arguments.
    The Reduce function is fed with a filename and a list of K2 values and for every
    item in the list, it calls Emit3 with this file name. So Reduce helps the Search
    program divide it's work to counting every file name occurrence in a single
    Reduce progress.
    As described, my implementation of K1 is a directory name and V1 is a substring.
    The implementation of K2 is the file name, which emitted by Map while filtering
    the directory (K1) using the substring (V1). As for V2, it does not have a
    specific implementation because the whole use of the value is to serve as a
    counter of appearances for each file name (K2). So every Emit2 will emit
    the file name with a nullptr and when the Reduce phase will take action it will
    merely count the size of the list of (V2) i.e. the number of nullptr items.
    As for K3 this is also representing a file name which passed the filtering.
    Again, for V3 the implementation was not required because the final output
    of the Search program is printing the file names without any additional
    information.

Design of the Framework implementation:
    Bla.


ANSWERS:
Theoretical Questions:
    1. Bla.

    2. Bla.

    3.  a. Bla.
        b. Bla.
        c. Bla.
        d. Bla.
        e. Bla.

    4. 	a. Stack:
            - Kernel-Level Thread - The stack isn't shared between parent and it's child.
			- User-Level Thread -   The stack isn't shared between parent and it's child.
			- Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the stack.
		b. Heap:  
            - Kernel-Level Thread - The heap is shared between parent and child.
			- User-Level Thread -   The heap is shared between parent and child.
            - Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the heap.
        c. Global Variables:
            - Kernel-Level Thread - The global variables are shared between the parent
                                    and it's child.
            - User-Level Thread -   The global variables are shared between the parent
                                    and it's child.
            - Process -             While all the parent's data is copied to the child procees
                                    this is just a copy of it and they don't share the
                                    global variables.

    5. The difference between deadlock and livelock is that in deadlock there are two
	or more threads/processes which hold some lock and wait for the lock of others and 
	so each one is watining for the other in some cyclic waiting, hence locked. 
	While in livelock the processes are locked, like in deadlock, the reason for this
	is different. In livelock each process is constantly changing it's state in order
	to assist the other processes to continue with their progress, so in livelock
	everybody is trying to make everybody to run, thus not making any progress, 
	and in deadlock each one is trying to make it's own process to run. As we mentioned 
	in class, livelock is a state where everybody is too polite, and we can think of 
	livelock as a situation of the processes trying to avoid in reaching a deadlock.
	An example of deadlock is like in the Dining Philosophers where each philosopher
	is holding one chopstick and attempts to hold the other chopstick, which is already
	held by another philosopher.
	An example of livelock is when two people attemp to get inside a room and get stuck
	the entrance because each one is too polite and wait for the other to get inside
	before him.
